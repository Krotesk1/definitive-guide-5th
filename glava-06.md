---
description: Основы диалплана
---

# Глава 6

> _Всё должно быть изложено так просто, как только возможно, но не более того._
>
> — Альберт Эйнштейн

Диалплан-это сердце вашей системы Asterisk. Он определяет, как звонки поступают в систему и выходят из нее. Диалплан является скриптовым языком, который определяет инструкции, которым Asterisk следует в ответ на вызовы, поступающие от каналов. В отличие от традиционных телефонных систем, диалплан Asterisk полностью настраивается.

Опытные разработчики программного обеспечения считают код диалплана Asterisk архаичным и часто предпочитают управлять потоком вызовов с помощью API Asterisk, таких как AMI и ARI \(которые мы обсудим в последующих главах\). Независимо от ваших планов в этом отношении, изучение поведения Asterisk намного проще, если вы сначала поймете диалплан. Возможно, также стоит отметить, что диалплан Asterisk настроен на производительность и поэтому является самым быстрым способом выполнения потока вызовов с точки зрения быстродействия и минимальной нагрузки на систему. Диалплан работает быстро.

В этой главе представлены основные понятия диалплана, которые лягут в основу любого диалплана, который вы пишете. Не пропускайте слишком много из этой главы, так как примеры строятся друг на друге, и это так принципиально важно для Asterisk. Обратите также внимание, что эта глава ни в коем случае не является исчерпывающим обзором всех возможных вещей, которые может сделать диалплан; наша цель - охватить только самое необходимое. В последующих главах мы рассмотрим более сложные темы диалплана. Вам рекомендуется экспериментировать.

## Синтаксис диалплана

Диалплан Asterisk задается в конфигурационном файле с именем _extensions.conf_, расположенном в каталоге _/etc/asterisk_.

Структура диалплана состоит из четырех иерархических компонентов: контекстов \(Context\), расширений \(Extension\), приоритетов \(Priority\) и приложений \(Application\) \(смотри Рисунок [6-1](https://github.com/Krotesk1/definitive-guide-5th/tree/e66e250765ca453e764e4340985eb43028d0f2fd/6.%20Dialplan%20Basics%20-%20Asterisk%20%20The%20Definitive%20Guide,%205th%20Edition.htm%22%20/l%20%22fig0601/README.md)\).

![&#x420;&#x438;&#x441;&#x443;&#x43D;&#x43E;&#x43A; 6-1. &#x418;&#x435;&#x440;&#x430;&#x440;&#x445;&#x438;&#x44F; &#x434;&#x438;&#x430;&#x43B;&#x43F;&#x43B;&#x430;&#x43D;&#x430;](.gitbook/assets/0%20%281%29.png)

Давайте нырнем прямо туда.

{% hint style="success" %}
**Примеры файлов конфигурации**

Основной файл _extensions.conf_ был создан как часть процесса установки ранее в этой книге. Мы будем опираться на этот файл в этой главе.

Asterisk также поставляется с подробным файлом _extensions.conf,_ который может быть установлен с образцами файлов конфигурации \(за это отвечает команда установки `make samples)`, и если вы запустили эту команду \(мы не рекомендуем запускать её во время установки, но это предлагается установщиком\), у вас, скорее всего, будет файл _/etc/asterisk/extensions.conf_, который переполнен информацией. Вместо того, чтобы начинать исправлять под себя файл пример, мы предлагаем вам построить свой _extensions.conf_ с нуля \(исходный файл вы можете переименовать или переместить куда-нибудь, если хотите сохранить в качестве источника примеров\).

Как и говорилось файл примера _extensions.conf_ - это фантастический ресурс, полный примеров и идей, которые вы можете использовать после того, как изучили основные понятия. Если вы выполнили наши инструкции по установке, то найдете файл _extensions.conf.sample_ в каталоге _~/src/asterisk-15.&lt;TAB&gt;/configs/samples_ \(наряду со многими другими образцами файлов конфигурации\).
{% endhint %}

\*\*\*\*

### Контексты

Диалплан делится на разделы, называемые контекстами, которые служат для разделения различных частей диалплана. Расширение, определенное в одном контексте, полностью изолировано от расширений в любом другом контексте, если взаимодействие специально не разрешено.

В качестве простого примера представим, что у нас есть две компании, совместно использующие сервер Asterisk. Если мы поместим каждого автосекретаря компании \(IVR\) в свой собственный контекст, две компании будут полностью отделены друг от друга. Это позволяет нам самостоятельно определить, что происходит, когда, скажем, набирается номер 0:

* Абоненты, набирающие 0 из голосового меню компании A, должны быть переданы администратору компании A.
* Абоненты, набравшие 0 в голосовом меню компании B, будут отправлены в отдел обслуживания клиентов компании B.

Оба абонента находятся в одной и той же системе, взаимодействуя с одной и той же абонентской группой, но поскольку они прибыли в разные контексты, то испытывают совершенно разные потоки вызовов. То, что происходит с каждым входящим вызовом, определяется кодом диалплана в каждом контексте.

{% hint style="info" %}
**Примечание**

Это очень важное соображение. С традиционными УАТС, как правило, существует набор значений по умолчанию для таких вещей, как прием, что означает, что если вы забудете их определить, они, вероятно, будут работать в любом случае. В Asterisk все наоборот. Если вы не скажете Asterisk, как обрабатывать каждую ситуацию, и он столкнется с чем-то, что не может обработать, вызов, как правило, будет отклонен.
{% endhint %}

Контексты определяются в файле _extensions.conf_, помещая имя контекста в квадратные скобки \(\[\]\). Имя может состоять из букв A - Z \(верхний и нижний регистр\), чисел от 0 до 9, а также дефиса и подчеркивания.\[^1\] Контекст для входящих вызовов от оператора связи может быть назван так:

```text
[incoming]
```

{% hint style="info" %}
**Примечание**

Имена контекстов имеют максимальную длину 79 символов \(80 символов минус 1 завершающий null\).
{% endhint %}

Или возможно:

```text
[incoming_company_A]
```

Что тогда, конечно, может потребовать что-то вроде:

```text
[incoming_company_B]
```

Все инструкции, помещенные после определения контекста, являются частью этого контекста, пока не будет определен следующий контекст.

В начале диалплана есть два специальных раздела с именами `[general]` и `[globals]`. Раздел `[general]` содержит список общих настроек абонентской группы \(о которых вам, вероятно, никогда не придется беспокоиться\), а контекст `[globals]`мы вскоре обсудим. На данный момент важно только знать, что эти две метки не являются контекстами, несмотря на использование синтаксиса контекста. Не используйте `[general]`, `[globals]` и `[default]` в качестве имен контекста, но в противном случае называйте свои контексты как угодно.

Контексты в типичном файле _extensions.conf_ могут быть структурированы примерно так:

```text
[general] ; он всегда должен быть здесь
[globals] ; глобальные переменные (мы обсудим их позже)
[incoming] ; звонки от поставщиков услуг могут поступать сюда
[sets] ; в простой системе мы можем использовать это
[sets1] ; многопользовательская же нуждается в этом (устройства от одной компании вводят диалплан здесь)
[sets2] ; ... и этом (другая группа устройств может войти в диалплан здесь)
[services] ; специальные услуги, такие как конференц-связь, могут быть определены здесь
```

Когда вы определяете канал \(что не делается в _extensions.conf_\), одним из обязательных параметров в каждом определении канала является `context`. _Контекст - это точка в диалплане, куда будут поступать соединения из этого канала._ Таким образом, способ подключения канала к диалплану осуществляется через контекст \(Рисунок 6-2\).

![&#x420;&#x438;&#x441;&#x443;&#x43D;&#x43E;&#x43A; 6-2. &#x421;&#x432;&#x44F;&#x437;&#x44C; &#x43C;&#x435;&#x436;&#x434;&#x443; &#x43A;&#x43E;&#x43D;&#x444;&#x438;&#x433;&#x443;&#x440;&#x430;&#x446;&#x438;&#x435;&#x439; &#x43A;&#x430;&#x43D;&#x430;&#x43B;&#x430; \(&#x441;&#x43B;&#x435;&#x432;&#x430;\) &#x438; &#x43A;&#x43E;&#x43D;&#x442;&#x435;&#x43A;&#x441;&#x442;&#x430;&#x43C;&#x438; &#x432; &#x434;&#x438;&#x430;&#x43B;&#x43F;&#x43B;&#x430;&#x43D;&#x435; \(&#x441;&#x43F;&#x440;&#x430;&#x432;&#x430;\)](.gitbook/assets/1.png)

{% hint style="info" %}
**Примечание**

Это одна из наиболее важных концепций для понимания при работе с каналами и абонентскими группами. Устранение неполадок потока вызовов намного проще, если вы понимаете связь между контекстом канала \(который сообщает каналу, где подключаться к диалплану\) и контекстом диалплана \(где мы создаем поток вызовов, который происходит при поступлении вызова\).
{% endhint %}

Важным \(возможно, самым важным\) использованием контекстов является обеспечение конфиденциальности и безопасности. При правильном использовании контекстов можно предоставить некоторым каналам доступ к функциям \(например, междугородним вызовам\), которые недоступны другим. Если вы не проработаете свою абонентскую группу тщательно, то можете непреднамеренно позволить другим использовать вашу систему в корыстных целях. Пожалуйста, имейте это в виду, когда строите свою систему Asterisk; в интернете есть много ботов, которые были специально написаны для идентификации и использования плохо защищенных систем Asterisk.

{% hint style="danger" %}
**Предупреждение**

[Asterisk wiki](https://wiki.asterisk.org/wiki/display/AST/Important+Security+Considerations) описывает несколько шагов, которые вы должны предпринять, чтобы сохранить вашу систему Asterisk в безопасности. Жизненно важно чтобы вы прочитали и поняли эту страницу. Если вы игнорируете меры безопасности, изложенные там, то можете в конечном итоге позволить всем и каждому совершать междугородние или платные звонки за ваш счет!

Если вы не относитесь к безопасности вашей системы Asterisk серьезно, то можете в конечном итоге поплатиться буквально. _Пожалуйста_, потратьте время и усилия, чтобы защитить вашу систему от мошенничества.
{% endhint %}

### Extensions \(расширения\)

В телекоммуникационной отрасли слово _extension \(расширение\)_ обычно относится к числовому идентификатору, который при наборе будет звонить на телефон \(или вызывать системный ресурс, такой как голосовая почта или очередь\). В Asterisk расширение представляет нечто гораздо более мощное, поскольку оно определяет уникальную серию шагов \(каждый шаг, содержащий приложение\), через которые Asterisk будет принимать этот вызов.

В каждом контексте мы можем определить столько \(или несколько\) расширений, сколько потребуется. Когда определенное расширение запускается \(входящим каналом\), Asterisk будет следовать шагам, определенным для этого расширения. Поэтому именно расширения определяют, что происходит с вызовами, когда они проходят через диалплан. Хотя расширения могут использоваться для указания телефонных добавочных номеров в традиционном смысле \(т.е. расширение 153 вызовет звонок SIP-телефона на столе Джона\), в диалплане Asterisk они могут использоваться для гораздо большего.

Синтаксис расширения - это слово `exten`, за которым следует стрелка, образованная знаком равенства и знаком больше, как это:

```text
exten =>
```

После этого следует имя \(или номер\) расширения.

При работе с традиционными телефонными системами мы склонны думать о расширениях как о номерах, которые вы набираете, чтобы сделать еще один телефонный звонок. В Asterisk имена расширений могут быть любыми комбинациями цифр и букв. В этой и следующей главах мы будем использовать как цифровые, так и буквенно-цифровые расширения.

{% hint style="warning" %}
**Совет**

Назначение имен для расширений может показаться необычной концепцией, но когда вы понимаете, что SIP поддерживает набор всех видов комбинаций символов \(все, что является допустимым URI, строго говоря\), это имеет смысл. Это одна из особенностей, которая делает Asterisk настолько гибким и мощным.
{% endhint %}

Каждый шаг расширения состоит из трех компонентов:

* Имя \(или номер\) расширения
* Приоритет \(каждое расширение может включать в себя несколько шагов; номер шага называется "приоритет”\)
* Приложение \(или команда\), которое будет выполняться на этом шаге

Эти три компонента разделены запятыми, как это:

```text
exten => name,priority,application()
```

Вот простой пример:

```text
exten => 123,1,Answer()
```

Имя расширения - `123`, приоритет - `1`, а приложение - `Answer()`.

### Приоритеты

Каждое расширение может иметь несколько шагов, называемых _приоритетами_. Приоритеты нумеруются последовательно, начиная с 1 и каждый выполняет одно конкретное приложение. Например, следующий добавочный номер ответит на звонок с приоритетом номер 1, а затем повесит трубку с приоритетом номер 2. Шаги в расширении происходят один за другим.

```text
exten => 123,1,Answer()
exten => 123,2,Hangup()
```

Совершенно очевидно, что этот код на самом деле не делает ничего полезного. Ключевым моментом здесь является то, что для конкретного расширения Asterisk следует за приоритетами по порядку.

```text
exten => 123,1,Answer()
exten => 123,2,делаем что-то
exten => 123,3,делаем что-то ещё
exten => 123,4,сделаем ещё одну вещь
exten => 123,5,Hangup()
```

Этот стиль синтаксиса диалплана все еще встречается время от времени, хотя \(как вы вскоре увидите\) он обычно больше не используется для нового кода. Более новый синтаксис похож, но упрощен.

#### Ненумерованные приоритеты

В старых версиях Asterisk нумерация приоритетов вызывала много проблем. Представьте себе расширение, которое имеет 15 приоритетов, а затем нужно что-то добавить на Шаге 2: все последующие приоритеты должны быть перенумерованы вручную. Asterisk не обрабатывает пропущенные шаги или неправильно пронумерованные приоритеты, и отладка этих типов ошибок была разочаровывающей.

Начиная с версии 1.2 Asterisk решил эту проблему: он ввел использование приоритета `n`, который означает “next." Каждый раз, когда Asterisk встречает приоритет с именем `n`, он принимает номер предыдущего приоритета и добавляет 1. Это упрощает внесение изменений в ваш диалплан, так как вам не нужно постоянно перенумеровывать все ваши шаги. Например, ваш диалплан может выглядеть примерно так:

```text
exten => 123,1,Answer()
exten => 123,n,do something
exten => 123,n,do something else
exten => 123,n,do one last thing
exten => 123,n,Hangup()
```

Внутри Asterisk будет вычислять следующий номер приоритета каждый раз, когда он сталкивается с `n`.\[^3\] Теперь, если мы хотим добавить новый элемент в приоритет 3, мы просто вводим новую строку, где она нам нужна, и не требуется перенумерация.

```text
exten => 123,1,Answer()
exten => 123,n,do something
exten => 123,n,SOME NEW THING
exten => 123,n,do something else
exten => 123,n,do one last thing
exten => 123,n,Hangup()
```

Имейте в виду, что вы всегда должны указывать приоритет № 1. Если вы случайно поставили `n` вместо `1` для первого приоритета \(распространенная ошибка даже среди опытных кодеров диалплана\), вы обнаружите после перезагрузки диалплана, что расширение не будет существовать.

#### Оператор same =&gt;

Для дальнейшего упрощения написания диалплана был создан новый синтаксис. Пока расширение остается неизменным, вы можете просто ввести `same =>` с последующим приоритетом и приложением, а не вводить полное расширение в каждой строке:

```text
exten => 123,1,Answer()
 same => n,do something
 same => n,do something
 same => n,do one last thing
 same => n,Hangup()
```

Этот стиль диалплана также облегчит копирование кода из одного расширения в другое. Это предпочтительный и рекомендуемый стиль. Единственная причина обсуждения предыдущих стилей - помочь понять, как мы сюда попали.

{% hint style="success" %}
Не ошибитесь, диалплан Asterisk весьма своеобразен. Многие люди избегают его вообще, и использовать AGI и ARI, чтобы написать свой диалплан.

Хотя, конечно, есть что сказать для написания диалплана на внешнем языке \(и мы рассмотрим его в последующих главах\), диалплан Asterisk является родным для него, и вы не получите лучшей производительности чем c ним. Код диалплана выполняется быстро.

Кроме того, если вы хотите понять, как Asterisk думает, вам нужно понять его диалплан.
{% endhint %}

#### Метки приоритетов

Метки приоритетов позволяют назначить имя приоритету в пределах расширения. Это должно гарантировать что вы можете ссылаться на приоритет иначе чем его номер \(который, вероятно, неизвестен, учитывая, что диалпланы теперь, как правило, используют ненумерованные приоритеты\). Позже вы узнаете, что часто необходимо отправлять вызовы из других частей диалплана на определенный приоритет в определенном расширении. Чтобы назначить текстовую метку приоритету, просто добавьте метку в скобках после приоритета, например:

```text
exten => 123,n(label),application()
```

Позже мы рассмотрим, как переключаться между различными приоритетами на основе логики диалплана. Вы увидите гораздо больше меток приоритетов и будете чаще использовать их в своих диалпланах.

{% hint style="danger" %}
**Предупреждение**

Очень распространенной ошибкой при написании меток является вставка запятой между then и \(, например:

`exten => 555,n,(label),application() ;<-- ЭТО НЕ БУДЕТ РАБОТАТЬ`

`exten => 556,n(label),application() ;<-- Это, что надо`

Эта ошибка нарушит часть вашего диалплана и вы получите сообщение об ошибке, указывающее, что приложение не может быть найдено.
{% endhint %}

### Приложения

Приложения — это рабочие лошадки диалплана. Каждое приложение выполняет определённое действие в текущем канале, такое как — воспроизведение звука, приём набора сигналов DTMF, поиск чего-то в базе данных, выполнение вызова в канал, завершение вызова, кормление кошки или что-то иное. В предыдущем примере мы показали два простых приложения: `Answer()` и `Hangup()`. Очевидно что они делают, но также очевидно что сами по себе они не очень полезны.

Некоторые приложения, включая `Answer()` и `Hangup()` не требуют дополнительных инструкций для выполнения своей задачи. Но большинству приложений требуется дополнительная информация. Эти дополнительные элементы или аргументы передаются в приложения чтобы повлиять на выполнение действий. Чтобы передать аргументы приложению, поместите их между круглыми скобками, которые следуют за именем приложения, разделяя запятыми. 

### Приложения Answer\(\), Playback\(\) и Hangup\(\)

Приложение `Answer()` используется для ответа на канал, который звонит. Это кажется простой вещью, но много вещей происходит на канале с этой одной командой. `Answer()` сообщает каналу отправить обратно на дальний конец сообщение, что вызов был отвечен, а также включить медиа-пути \(сетевые потоки, которые будут нести звук между вызывающим абонентом и системой\). Как мы уже упоминали ранее, `Answer()` не принимает аргументов. `Answer()` не всегда требуется \(на самом деле, в некоторых случаях он может быть вообще нежелательным\), но это эффективный способ обеспечить подключение канала перед выполнением дальнейших действий.

{% hint style="success" %}
**Приложение Progress\(\)**

Иногда полезно иметь возможность передавать информацию обратно в сеть перед ответом на вызов. Приложение `Progress()` пытается предоставить информацию о ходе выполнения вызова исходному каналу. Некоторые операторы связи ожидают этого, и таким образом вы можете решить странные проблемы с сигнализацией, вставив `Progress()` в диалплан, куда поступают ваши входящие вызовы. С точки зрения биллинга, использование `Progress()` позволяет поставщику услуг знать, что вы обрабатываете вызов, не запуская счетчик биллинга.
{% endhint %}

Приложение `Playback()` используется для воспроизведения ранее записанного звукового файла по каналу. Ввод от пользователя игнорируется, что означает невозможность использования `Playback()` в автосекретаре, например если не хотите принимать ввод в этот момент.

{% hint style="info" %}
**Подсказка**

Asterisk поставляется со многими профессионально записанными звуковыми файлами, которые должны быть найдены в каталоге звуков по умолчанию \(обычно _/var/lib/asterisk/sounds_\). При компиляции Asterisk можно установить различные наборы образцов звуков, записанных на различных языках и в различных форматах файлов. Мы будем использовать эти файлы во многих наших примерах. Некоторые из файлов в наших примерах взяты из дополнительного звукового пакета, который мы установили в [Главе 3](glava-03.md). Вы также можете иметь свои собственные звуковые подсказки, записанные в тех же голосах, что и стоковые подсказки, посетив [www.theivrvoice.com](https://github.com/Krotesk1/definitive-guide-5th/tree/e66e250765ca453e764e4340985eb43028d0f2fd/www.theivrvoice.com). Далее в книге мы поговорим о том, как можно использовать телефон и абонентскую группу для создания и управления собственными системными записями \(или импорта _.wav_ файлов\).
{% endhint %}

Чтобы использовать функцию `Playback()`, укажите имя файла в качестве аргумента. Например, воспроизведение `Playback(filename)`воспроизведёт звуковой файл с именем _filename.wav_, предполагая, что он находится в каталоге звуков по умолчанию. Обратите внимание, что вы можете включить полный путь к файлу, если хотите, например:

```text
Playback(/home/john/sounds/filename)
```

В предыдущем примере будет воспроизводиться _filename.wav_ из каталога _/home/john/sounds_. Это может быть проблематично из-за потенциальных проблем с правами доступа к файлам. Если вы планируете иметь много пользовательских звуков в своей системе, то вам, вероятно, понадобится выделенный каталог для них, и нужно будет проверить, чтобы Asterisk мог найти и воспроизвести файлы.

Вы также можете использовать относительные пути из каталога звуков Asterisk, как показано ниже:

```text
Playback(custom/filename)
```

В этом примере будет воспроизводиться _filename.wav_ из подкаталога _custom_ каталога звуков по умолчанию \(возможно _/var/lib/asterisk/sounds/en/custom/filename.wav_\). Если указанный каталог содержит более одного файла с этим именем, но с разными расширениями, Asterisk автоматически воспроизведёт лучший.

Приложение `Hangup()` делает именно то, что следует из его названия: оно завершает активный канал. Вы должны использовать это приложение в конце контекста, когда хотите завершить текущий вызов, чтобы убедиться, что абоненты не продолжают выполнение диалплана таким образом, который вы, возможно, не ожидали. Приложение `Hangup()` не требует никаких аргументов, но вы можете передать код причины ISDN если захотите, например `Hangup(16)` и он будет переведен в сопоставимое сообщение SIP и отправлено на дальний конец.

По мере работы над книгой мы будем знакомить вас со многими другими приложениями Asterisk, но пока достаточно теории; давайте напишем диалплан!

### Базовый прототип диалплана

Таким образом, повторю, что форма всех диалпланов строится на основе этих четырех понятий: контекст, расширение, приоритет и приложение \(Рисунок6-3\).

![&#x420;&#x438;&#x441;&#x443;&#x43D;&#x43E;&#x43A; 6-3. &#x41F;&#x440;&#x43E;&#x442;&#x43E;&#x442;&#x438;&#x43F; &#x434;&#x438;&#x430;&#x43B;&#x43F;&#x43B;&#x430;&#x43D;&#x430;](.gitbook/assets/2.png)

## Простой диалплан

Ладно, хватит теории. Откройте файл _/etc/asterisk/extensions.conf_ в вашем любимом редакторе, и давайте посмотрим на ваш первый диалплан \(который был создан в [Главе 5](glava-05.md)\). Мы собираемся добавить к нему.

### Hello World

Как это обычно бывает во многих технологических книгах \(особенно в книгах по компьютерному программированию\), наш первый пример называется “Hello World.”

В первом приоритете нашего расширения мы отвечаем на вызов. Во втором мы проигрываем звуковой файл с именем _hello-world_, а в третьем вешаем трубку. Код, который нас интересует для этого примера выглядит так:

```text
exten => 200,1,Answer()
    same => n,Playback(hello-world)
    same => n,Hangup()
```

Если вы следовали [Главе 5](glava-05.md), у вас уже будет настроен канал или два, а также пример диалплана, который содержит этот код. Если нет, то вам нужен файл _extensions.conf_ в каталоге _/etc/asterisk_, содержащий следующий код:

```text
[general]
[globals]

[sets]
exten => 100,1,Dial(PJSIP/0000f30A0A01) ; Замените 0000f30A0A01 на имя вашего устройства

exten => 101,1,Dial(PJSIP/SOFTPHONE_A)

exten => 102,1,Dial(PJSIP/0000f30B0B02)

exten => 103,1,Dial(PJSIP/SOFTPHONE_B)

exten => 200,1,Answer()
    same => n,Playback(hello-world)
    same => n,Hangup()
```

{% hint style="info" %}
**Подсказка**

Если у вас нет настроенных каналов, сейчас самое время создать их. Существует реальное удовлетворение, которое приходит от передачи вашего первого вызова в диалплан Asterisk в системе, которую вы построили с нуля. Люди получают эту ухмылку на лицах когда понимают, что они только что создали телефонную систему. Это удовольствие может быть и вашим, поэтому, пожалуйста, не идите дальше, пока не сделаете эту маленькую работу диалплана. Если у вас есть какие-либо проблемы, вернитесь к [Главе 5](glava-05.md) и проработайте примеры оттуда.
{% endhint %}

Если у вас еще нет этого кода диалплана, то нужно будет добавить его и перезагрузить диалплан с помощью этой команды CLI:

```text
$ sudo asterisk -rvvvvv # ('r' подключается к демону Asterisk; 'v' означает verbosity)
*CLI> dialplan reload
```

или вы можете выполнить команду непосредственно из оболочки с помощью:

```text
$ sudo asterisk -rx "dialplan reload" # ('rx' выполнение команды Asterisk и возврат)
```

Вызов расширения 200 с любого из ваших настроенных телефонов должен вознаградить вас дружелюбным голосом Эллисон Смит, говорящим: "Hello, World.”

Если это не работает, проверьте консоль Asterisk на наличие сообщений об ошибках и убедитесь, что ваши каналы назначены контексту `sets`.

{% hint style="danger" %}
**Предупреждение**

Мы не рекомендуем Вам продвигаться вперед в этой книге, пока вы не проверите следующее:

1. Вызовы между добавочными номерами 100 и 101 работают.
2. Вызов расширения 200 воспроизводит “Hello World.”
{% endhint %}

Хотя этот пример очень короткий и простой, он подчеркивает основные концепции диалплана: контексты, расширения, приоритеты и приложения. Теперь у вас есть фундаментальные знания, на которых строятся все диалпланы.

{% hint style="success" %}
Когда вы создаете диалплан, будет полезно открыть CLI Asterisk в новом окне. Вы будете часто перезагружать диалплан, и во время тестирования потока вызовов захотите увидеть что происходит и происходит. CLI Asterisk полезен для обеих этих вещей.

```text
$ sudo asterisk -rvvvvv
*CLI> dialplan reload # из командной строки Астериска перезагружает диалплан
```

Поэтому лучше всего было бы редактировать в одном окне, а перезагружать и отлаживать в другом.
{% endhint %}

## Создание интерактивного диалплана

Диалплан, который мы только что построили, был статическим; он всегда будет выполнять одни и те же действия при каждом вызове. Многие диалпланы также нуждаются в логике для выполнения различных действий на основе ввода пользователя, поэтому давайте посмотрим на это сейчас.

### Приложения Goto\(\), Background\(\) и WaitExten\(\)

Как следует из названия, приложение `Goto()` используется для отправки вызова в другую часть диалплана. `Goto()` требует, чтобы мы передали контекст назначения, расширение и приоритет в качестве аргументов, например:

```text
 same => n,Goto(context,extension,priority)
```

Мы создадим новый контекст под названием `TestMenu` и создадим расширение в нашем контексте `sets`, которое будет передавать вызовы в этот контекст с помощью `Goto()`:

```text
exten => 200,1,Answer()
 same => n,Playback(hello-world)
 same => n,Hangup()

exten => 201,1,Goto(TestMenu,start,1) ; add this to the end of the
 ; [sets] context
[TestMenu]
exten => start,1,Answer()
```

Теперь, когда устройство входит в контекст `[sets]` и набирает 201, вызов будет передан в расширение `start` в контексте `TestMenu` \(который в настоящее время не будет делать ничего интересного, потому что у нас есть ещё код для записи\).

{% hint style="info" %}
**Примечание**

Мы использовали расширение `start` в этом примере, но могли бы использовать все что угодно в качестве имени расширения, либо числовое, либо буквенное. Мы предпочитаем использовать буквенные-символы для расширений, которые не доступны напрямую, так как это упрощает чтение диалплана. Суть в том, что можно было бы назвать нашей целью расширения `123` или `xyz321`, или `99luftballons`, или всё что угодно чтобы начать. Слово _start_ не означает ничего особенного для диалплана; это просто имя расширения.
{% endhint %}

Одним из наиболее полезных приложений в интерактивном диалплане Asterisk является приложение `Background()`. Как и `Playback()`, оно воспроизводит записанный звуковой файл. Однако в отличие от функции `Playback()`, когда вызывающий абонент нажимает клавишу \(или серию клавиш\) на клавиатуре своего телефона, он прерывает воспроизведение и передает вызов на добавочный номер, соответствующий нажатой цифре\(цифрам\). Если вызывающий абонент нажимает 5, например, Asterisk прекратит воспроизведение звуковой подсказки и отправит управление вызовом на первый приоритет расширения 5 \(при условии, что расширение 5 существует для отправки вызова\).

Наиболее распространенным использованием приложения `Background()` является создание основных голосовых меню \(часто называемых _автосекретарями_, _IVR_, или _телефонными деревьями_\). Многие компании используют голосовые меню для направления абонентов на соответствующие добавочные номера, тем самым освобождая своих администраторов от необходимости отвечать на каждый вызов.

Background\(\) имеет тот же синтаксис как и Playback\(\):

```text
[TestMenu]
exten => start,1,Answer()
    same => n,Background(enter-ext-of-person)
```

Если вы хотите, чтобы Asterisk ждал ввода от вызывающего абонента после завершения воспроизведения звуковой подсказки, вы можете использовать `WaitExten()`. Приложение `WaitExten()` ожидает пока вызывающий абонент введет цифры DTMF, и используется непосредственно после приложения `Background()`, например:

```text
[TestMenu]
exten => start,1,Answer()
 same => n,Background(enter-ext-of-person)
 same => n,WaitExten()
```

Если вы хотите, чтобы приложение `WaitExten()` ждало ввода для ответа определенное количество секунд \(вместо использования таймаута по умолчанию\), просто передайте количество секунд в качестве первого аргумента `WaitExten()`, например:

```text
 same => n,WaitExten(5) ; Мы всегда передаем аргумент времени для WaitExten()
```

И `Background()`, и `WaitExten()` позволяют абоненту вводить цифры DTMF. Затем Asterisk пытается найти расширение, которое соответствует цифрам введенным вызывающим абонентом, в текущем контексте. Если Asterisk найдет совпадение, то отправит вызов на этот добавочный номер. Давайте продемонстрируем, добавив несколько строк в наш пример диалплана:

```text
[TestMenu]
exten => start,1,Answer()
    same => n,Background(enter-ext-of-person)
    same => n,WaitExten(5)

exten => 1,1,Playback(digits/1)
exten => 2,1,Playback(digits/2)
```

После внесения этих изменений сохраните и перезагрузите диалплан:

```text
*CLI> dialplan reload
```

Если вы звоните в расширение 201, то должны услышать звуковое приглашение, которое говорит: “Enter the extension of the person you are trying to reach". Система будет ждать 5 секунд, пока вы введете цифру. Если вы нажмете 1 или 2, Asterisk будет действовать соответственно расширению и считывать эту цифру обратно к вам. Поскольку мы не предоставили никаких дальнейших инструкций, ваш звонок будет закончен. Вы также обнаружите, что если введете другую цифру \(например, 3\), диалплан не сможет продолжиться.

Давайте немного приукрасим. Мы собираемся использовать приложение `Goto()`, чтобы заставить диалплан повторить приветствие после воспроизведения номера:

```text
[TestMenu]
exten => start,1,Answer()
 same => n,Background(enter-ext-of-person)
 same => n,WaitExten(5)

exten => 1,1,Playback(digits/1)
 same => n,Goto(TestMenu,start,1)

exten => 2,1,Playback(digits/2)
 same => n,Goto(TestMenu,start,1)
```

Эти новые строки отправят управление вызовом обратно в расширение `start` после воспроизведения набранного номера.

{% hint style="info" %}
**Подсказка**

Если посмотрите детали приложения `Goto()`, то обнаружите что вы действительно можете передать в приложение один, два или три аргумента. Если передадите один аргумент - Asterisk предположит что это приоритет назначения в текущем расширении. Если передадите два аргумента - Asterisk будет рассматривать их как расширение и приоритет для перехода в текущем контексте.

В этом примере мы передали все три аргумента для ясности, но передача только расширения и приоритета имела бы тот же эффект, поскольку контекст назначения совпадает с исходным контекстом.
{% endhint %}

### Обработка неверных значений и тайм-аутов

Нам нужно расширение для недопустимых значений. В Asterisk, когда контекст получает запрос на расширение, которое не является допустимым в этом контексте \(например, нажатие 9 в предыдущем примере\), вызов отправляется на расширение `i`. Нам также нужно расширение для обработки ситуаций, когда вызывающий абонент не делает ввода \(тайм-аут по умолчанию составляет 10 секунд\). Вызовы будут отправлены на расширение `t`, если вызывающий слишком долго нажимает цифру после вызова `WaitExten()`. Вот как будет выглядеть наш диалплан после добавления этих двух расширений:

```text
[TestMenu]
exten => start,1,Answer()
    same => n,Background(enter-ext-of-person)
    same => n,WaitExten(5)

exten => 1,1,Playback(digits/1)
    same => n,Goto(TestMenu,start,1)

exten => 2,1,Playback(digits/2)
    same => n,Goto(TestMenu,start,1)

exten => i,1,Playback(pbx-invalid)
    same => n,Goto(TestMenu,start,1)

exten => t,1,Playback(please-try-again)
    same => n,Goto(TestMenu,start,1)
```

Использование расширений `i` и `t` делает наше меню более надежным и удобным для пользователя. Но оно по прежнему все еще довольно ограничено, потому что внешние абоненты все еще не имеют возможности соединиться с живым человеком. Для этого нам нужно будет узнать о приложении `Dial()`.

### Использование приложения Dial\(\)

Одной из наиболее ценных особенностей Asterisk является возможность подключения различных абонентов друг к другу. Хотя Asterisk в настоящее время используется в основном для SIP-соединений, он поддерживает широкий спектр типов каналов \(от аналоговых до SS7 и различных старых протоколов VoIP, таких как MGCP и SCCP\). Asterisk берет на себя большую часть тяжелой работы по подключению и переводу между разрозненными сетями. Все, что вам нужно сделать, это научиться использовать приложение `Dial()`.

Синтаксис приложения `Dial()` является более сложным, чем у других приложений, которые мы использовали до этого, но оно является тем, где происходит большая часть магии Asterisk. `Dial()` принимает до четырех аргументов, которые мы рассмотрим далее.

Синтаксис `Dial()` выглядит следующим образом:

```text
Dial(Technology/Resource[&Technology2/Resource2[&...]][,timeout[,options[,URL]]])
```

Проще говоря, вы сообщаете `Dial()`, на какой канал хотите отправить вызов и устанавливаете несколько параметров для настройки поведения. Использование `Dial()` может быть сложным, но в самом основном оно очень простое.

#### Аргумент 1: назначение

Первый аргумент-это назначение, которое вы пытаетесь вызвать, которое \(в самой простой форме\) состоит из технологии \(или транспорта\), через которую выполняется вызов, косой черты и адреса удаленной конечной точки или ресурса.

{% hint style="info" %}
**Примечание**

В эти дни вы, скорее всего, будете использовать PJSIP в качестве типа канала, но в не слишком далеком прошлом общие типы технологий также включали DAHDI \(для аналоговых и T1/E1/J1 каналов\), старый канал SIP \(до PJSIP\) и IAX2. Если вы посмотрите на более старый диалплан, то можете увидеть некоторые из этих представленных протоколов. В дальнейшем рекомендуется и поддерживается только PJSIP и DAHDI.
{% endhint %}

Предположим, что мы хотим вызвать один из наших каналов PJSIP с именем `SOFTPHONE_B`. технология - PJSIP, а идентификатор ресурса \(или канала\) - `SOFTPHONE_B`. Аналогично, вызов устройства DAHDI \(определенного в _chan\_dahdi.conf_\) может иметь пункт назначения `DAHDI/14169671111`. Если бы мы хотели чтобы Asterisk вызывал канал `PJSIP/ SOFTPHONE_B` при достижении расширения `103` в диалплане то добавили бы следующее расширение:

```text
exten => 101,1,Dial(PJSIP/SOFTPHONE_A)
exten => 103,1,Dial(PJSIP/SOFTPHONE_B)
exten => 200,1,Answer()
```

Мы также можем одновременно набирать несколько каналов, объединяя назначения амперсандом \( `&` \), например:

```text
exten => 101,1,Dial(PJSIP/SOFTPHONE_A)
exten => 103,1,Dial(PJSIP/SOFTPHONE_B)
exten => 110,1,Dial(PJSIP/0000f30A0A01&PJSIP/SOFTPHONE_A&PJSIP/SOFTPHONE_B)
exten => 200,1,Answer()
```

Приложение Dial\(\) вызовет все указанные назначения одновременно и соединит входящий вызов с тем каналом назначения, который ответит первым \(другие каналы немедленно прекратят звонить\). Если приложение `Dial()` не может связаться ни с одним из назначений, Asterisk установит переменную с именем `DIALSTATUS` соответственно причине, по которой не может набрать назначение, и продолжит со следующим приоритетом в расширении.

Приложение `Dial()` также позволяет подключаться к удаленной конечной точке VoIP, ранее не определенной в одном из файлов конфигурации канала. Полный синтаксис:

```text
Dial(technology/user[:password]@remote_host[:port][/remote_extension])
```

Полный синтаксис приложения `Dial()` немного отличается для каналов DAHDI:

```text
Dial(DAHDI/[gGrR]channel_or_group[/remote_extension])
```

Например, вот как бы вы набрали `1-800-555-1212` на канале DAHDI номер 4:

```text
exten => 501,1,Dial(DAHDI/4/18005551212)
```

#### Аргумент 2: таймаут

Вторым аргументом приложения `Dial()` является тайм-аут, заданный в секундах. Если задан тайм-аут, `Dial()` попытается вызвать указанное назначение\(я\) в течение этого количества секунд, прежде чем сдаться и перейти к следующему приоритету в расширении. Если тайм-аут не указан, `Dial()` будет продолжать набирать вызываемый канал\(ы\) пока кто-то не ответит или вызывающий абонент не повесит трубку. Давайте добавим тайм-аут в 10 секунд к нашему расширению:

```text
exten => 101,1,Dial(PJSIP/SOFTPHONE_A)
exten => 102,1,Dial(PJSIP/0000f30B0B02,10)
exten => 103,1,Dial(PJSIP/SOFTPHONE_B)
```

Если на вызов отвечают до истечения тайм-аута, каналы соединяются и диалплан выполняется. Если адресат просто не отвечает, занят или недоступен иным образом, Asterisk установит переменную с именем `DIALSTATUS`, а затем продолжит работу со следующим приоритетом в расширении.

Давайте поместим то, что мы узнали ранее, в другой пример:

```text
exten => 102,1,Dial(PJSIP/0000f30B0B02,10)
 same => n,Playback(vm-nobodyavail)
 same => n,Hangup()
```

Как вы можете видеть, этот пример будет играть звуковой файл _vm-nobodyavail.gsm,_ если вызов остается без ответа \(а затем повесит трубку\). Обратите внимание, что это на самом деле не обеспечивает голосовую почту; мы просто играем подсказку, которая могла бы быть любой действительной подсказкой. Мы рассмотрим отправку звонков на голосовую почту позже.

#### Аргумент 3: опции

Третий аргумент для `Dial()` - это строка параметров. Он может содержать один или несколько символов, которые изменяют поведение приложения `Dial()`. Хотя список возможных вариантов слишком длинный чтобы охватить его здесь, одним из самых популярных является вариант `m`. Если вы поместите букву `m` в качестве третьего аргумента, вызывающая сторона услышит музыку удержания вместо звонка во время вызова канала назначения \(при условии, конечно, что музыка на удержании была настроена правильно\). Чтобы добавить опцию `m` к нашему последнему примеру, мы просто изменим первую строку:

```text
exten => 102,1,Dial(PJSIP/0000f30B0B02,10,m)
    same => n,Playback(vm-nobodyavail)
    same => n,Hangup()
```

#### Аргумент 4: URI

Четвертым и последним аргументом приложения `Dial()` является URI. Если канал назначения поддерживает получение URI во время вызова, указанный URI будет отправлен \(например, если у вас есть IP-телефон, который поддерживает получение URI, он появится на дисплее телефона; аналогично, если вы используете софтфон, URI может появиться на экране вашего компьютера\). Этот аргумент используется очень редко.

#### Обновление диалплана

Давайте изменим расширения 1 и 2 в нашем меню, чтобы использовать приложение `Dial()`, и добавим расширения 3 и 4 просто для хорошей меры:

```text
[TestMenu]
exten => start,1,Answer()
    same => n,Background(enter-ext-of-person)
    same => n,WaitExten(5)

exten => 1,1,Dial(PJSIP/0000f30A0A01,10)
    same => n,Playback(vm-nobodyavail)
    same => n,Hangup()

exten => 2,1,Dial(PJSIP/0000f30B0B02,10)
    same => n,Playback(vm-nobodyavail)
    same => n,Hangup()

exten => 3,1,Dial(PJSIP/SOFTPHONE_A,10)
    same => n,Playback(vm-nobodyavail)
    same => n,Hangup()

exten => 4,1,Dial(PJSIP/SOFTPHONE_B,10)
    same => n,Playback(vm-nobodyavail)
    same => n,Hangup()

exten => i,1,Playback(pbx-invalid)
    same => n,Goto(TestMenu,start,1)

exten => t,1,Playback(vm-goodbye)
    same => n,Hangup()
```

#### Пустые аргументы

Обратите внимание, что второй, третий и четвертый аргументы могут быть оставлены пустыми; требуется только первый аргумент. Например, если вы хотите указать параметр, но не тайм-аут, просто оставьте аргумент timeout пустым, например:

```text
exten => 4,1,Dial(SIP/SOFTPHONE_B,,m)
```

### Использование переменных

Если у вас есть опыт программирования, вы уже понимаете что такое переменная. Если нет, то мы кратко объясним, что такое переменные и как они используются. Любая работа диалплана за пределами очень простых примеров, только что приведенных, значительно выиграет от использования переменных. Они являются одной из полезных функций настраиваемого диалплана, который вы не найдете в типичной проприетарной АТС.

_Переменная_ - это именованный контейнер, который может содержать значение. Думайте о ней как о почтовом ящике. Преимущество переменной заключается в том, что ее содержимое может изменяться, но ее имя не изменяется, что означает - вы можете написать код, который ссылается на имя переменной, и не беспокоиться о том, какое значение будет. Практически невозможно сделать какое-либо полезное программирование без переменных.

Существует два способа ссылки на переменную. Чтобы ссылаться на имя переменной, просто введите имя переменной. Если, с другой стороны, вы хотите ссылаться на значение переменной, необходимо ввести знак доллара, открывающую фигурную скобку, имя переменной и закрывающую фигурную скобку. Итак, чтобы использовать аналогию с почтовым ящиком, вы ссылаетесь на сам ящик, просто используя его имя, и вы ссылаетесь на содержимое с использованием обертки `${}`. Переменная с именем MyVar называется `MyVar`, и доступ к ее содержимому осуществляется с помощью `${MyVar}`. Вот как мы могли бы использовать переменную внутри приложения `Dial()`:

```text
exten => 203,1,Noop(say some digits)
 same => n,Answer()
 same => n,Set(SomeDigits=123)
 same => n,SayDigits(${SomeDigits})
 same => n,Wait(.25)
 same => n,Set(SomeDigits=543)
 same => n,SayDigits(${SomeDigits})
```

В нашем диалплане всякий раз, когда мы ссылаемся на `${SomeDigits}`, Asterisk автоматически заменит его любым значением, присвоенным переменной с именем `SomeDigits`.

{% hint style="info" %}
**Подсказка**

Обратите внимание, что имена переменных чувствительны к регистру. Переменная по имени `SOMEDIGITS` отличается от переменной `SomeDigits`. Вы также должны знать, что любые переменные, заданные Asterisk, будут прописными. Некоторые переменные, такие как `CHANNEL` и `EXTEND`, зарезервированы Asterisk. Вы не должны пытаться установить их. Распространенным является запись глобальных переменных в верхнем регистре и переменных канала в виде Pascal/Camel, но это не является строго обязательным.
{% endhint %}

Существует три типа переменных, которые мы можем использовать в нашем диалплане: глобальные переменные, переменные канала и переменные среды. Давайте воспользуемся моментом, чтобы посмотреть на каждый тип.

#### Глобальные переменные

Как следует из их названия, _глобальные_ переменные видны всем каналам в любое время. Глобальные переменные полезны тем, что их можно использовать в любом месте диалплана для повышения читаемости и управляемости. Предположим на мгновение, что у вас есть большой диалплан и несколько сотен ссылок на канал `PJSIP/0000f30A0A01`. Теперь представьте, что вы заменили телефон другим устройством \(возможно, другим MAC-адресом\) и должны теперь пройти через свой диалплан и изменить все эти ссылки на `PJSIP/0000f30A0A01`. Не очень удобно.

С другой стороны, если бы вы определили глобальную переменную, содержащую значение `PJSIP/0000f30A0A01` в начале вашего диалплана, а затем ссылались на нее, то пришлось бы изменить только одну строку кода, чтобы повлиять на все места в диалплане, где использовался этот канал.

Глобальные переменные должны быть объявлены в контексте `[globals]` в начале _extensions.conf_. В качестве примера мы создадим несколько глобальных переменных, которые хранят идентификаторы каналов наших устройств. Эти переменные задаются во время анализа диалплана Asterisk:

```text
[globals]
UserA_DeskPhone=PJSIP/0000f30A0A01
UserA_SoftPhone=PJSIP/SOFTPHONE_A
UserB_DeskPhone=PJSIP/0000f30B0B02
UserB_SoftPhone=PJSIP/SOFTPHONE_B
```

Мы вернемся к ним позже.

#### Канальные переменные

Переменная _канала_ - это переменная, связанная только с определенным вызовом. В отличие от глобальных переменных, переменные канала определяются только на время текущего вызова и доступны только для каналов, участвующих в этом вызове.

Существует множество предопределенных переменных канала, доступных для использования в диалплане, которые описаны в [Asterisk wiki](https://wiki.asterisk.org/wiki/display/AST/Channel+Variables). Вы определяете переменную канала с расширением 203 и приложением Set\(\) :

```text
exten => 203,1,Noop(say some digits)
    same => n,Set(SomeDigits=123)
    same => n,SayDigits(${SomeDigits})
    same => n,Wait(.25)
    same => n,Set(SomeDigits=543)
    same => n,SayDigits(${SomeDigits})
```

Вы увидите гораздо больше переменных канала. Читайте дальше.

#### Переменные среды

Переменные _среды_ - это способ доступа к переменным среды Unix из Asterisk. На них ссылаются с помощью функции диалплана `ENV()` . Синтаксис выглядит как `${ENV(`_`var`_`)}`, где _`var`_- переменная среды Unix, на которую вы хотите ссылаться. Переменные среды обычно не используются в диалплане Asterisk, но они доступны в случае необходимости.

#### Добавление переменных в ваш диалплан

Теперь, когда мы узнали о переменных, давайте включим их в наш диалплан. Мы добавим три глобальные переменные, которые свяжут имя переменной с именем канала:

```text
[general]
[globals]
UserA_DeskPhone=PJSIP/0000f30A0A01
UserA_SoftPhone=PJSIP/SOFTPHONE_A
UserB_DeskPhone=PJSIP/0000f30B0B02
UserB_SoftPhone=PJSIP/SOFTPHONE_B
[sets]
exten => 100,1,Dial(${UserA_DeskPhone})
exten => 101,1,Dial(${UserA_SoftPhone})
exten => 102,1,Dial(${UserB_DeskPhone},10)
 same => n,Playback(vm-nobodyavail)
 same => n,Hangup()
exten => 103,1,Dial(${UserB_SoftPhone})
exten => 110,1,Dial(${UserA_DeskPhone}&${UserA_SoftPhone}&${UserB_SoftPhone})
exten => 200,1,Answer()
Let’s update the test menu as well:
[TestMenu]
exten => start,1,Answer()
 same => n,Background(enter-ext-of-person)
 same => n,WaitExten(5)
exten => 1,1,Dial(${UserA_DeskPhone},10)
 same => n,Playback(vm-nobodyavail)
 same => n,Hangup()
exten => 2,1,Dial(${UserA_SoftPhone},10)
 same => n,Playback(vm-nobodyavail)
 same => n,Hangup()
exten => 3,1,Dial(${UserB_DeskPhone},10)
 same => n,Playback(vm-nobodyavail)
 same => n,Hangup()
exten => 4,1,Dial(${UserB_SoftPhone},10)
 same => n,Playback(vm-nobodyavail)
 same => n,Hangup()
exten => i,1,Playback(pbx-invalid)
```

Редко имеет смысл жестко кодировать данные в диалплане. Почти всегда лучше использовать переменную.

Убедитесь, что вы протестировали это чтобы убедиться, что у вас нет никаких опечаток, а также посмотреть, как это выглядит в Asterisk CLI при выполнении:

```text
# asterisk -rvvvvvv
*CLI> dialplan reload
 -- Executing [201@sets:1] Goto("PJSIP/0000f30A0A01", "TestMenu,start,1")
 -- Goto (TestMenu,start,1)
 -- Exec [start@TestMenu:1] Answer("PJSIP/0000f30A0A01", "")
 -- Exec [start@TestMenu:2] BackGround("PJSIP/0000f30A0A01", "enter-ext-of-person")
 -- <PJSIP/0000f30A0A01> Playing 'enter-ext-of-person.slin' (language 'en')
 -- Exec [1@TestMenu:1] Dial("PJSIP/0000f30A0A01", "PJSIP/0000f30A0A01,10")
 -- Called PJSIP/0000f30A0A01
 -- PJSIP/0000f30A0A01-00000011 is ringing
 == Spawn extension (TestMenu, 1, 1) exited non-zero on 'PJSIP/0000f30A0A01'
```

#### Объединение переменных

Чтобы объединить переменные, просто поместите их вместе, например:

```text
exten => 204,1,Answer()
 same => n,Answer()
 same => n,Set(ONETWO=12)
 same => n,Set(THREEFOUR=34)
 same => n,SayDigits(${ONETWO}${THREEFOUR}) ; проще простого
 same => n,Wait(0.2)
 same => n,Set(NOTFIVE=${THREEFOUR}${ONETWO}) ; легче не бывает
 same => n,SayNumber(${NOTFIVE}) ; видите, что мы здесь сделали?
 same => n,Wait(0.2)
 same => n,SayDigits(2${ONETWO}3) ; Вы можете объединять постоянные и переменные
```

#### Наследование переменных канала

Переменные канала всегда связаны с исходным каналом, который их задает, и больше не доступны после передачи канала.

Чтобы разрешить переменным канала следовать за каналом при его передаче по системе, необходимо использовать наследование переменных канала. Существует два модификатора, которые позволяют переменной канала следовать за каналом: одиночное подчеркивание и двойное подчеркивание.

Одиночное подчеркивание \(\_\) приводит к тому, что переменная канала наследуется каналом для одной передачи, после чего она больше недоступна для дополнительных передач. Если вы используете двойное подчеркивание \(\_\_\), переменная канала будет наследоваться на протяжении всего срока жизни этого канала.

Установка переменных канала для наследования просто требует префикса имени канала с одним или двойным подчеркиванием. Затем на переменные канала ссылаются точно так же, как и обычно.

Вот пример установки переменной канала для наследования одной передачи:

```text
exten => example,1,Set(_MyVariable=thisValue)
```

Вот пример установки переменной канала для бесконечного наследования передачи:

```text
exten => example,1,Set(__MyVariable=thisValue)
```

Если вы хотите прочитать значение переменной канала, вы не используете подчеркивание\(я\):

```text
exten => example,1,Verbose(1,Value of MyVariable is: ${MyVariable})
```

### Совпадения по шаблонам

Если мы хотим чтобы люди могли набирать номер через Asterisk и подключаться к внешним ресурсам, нам нужен способ сопоставить любой возможный номер телефона, который может набрать вызывающий абонент. Для таких ситуаций Asterisk предлагает сопоставление шаблонов. Сопоставление шаблонов позволяет создать в диалплане одно расширение, которое соответствует множеству различных номеров. Это чрезвычайно полезно.

#### Синтаксис сравнения по шаблонам

Когда мы используем совпадение шаблонов, определенные буквы и символы представляют то, что мы пытаемся сопоставить. Шаблоны всегда начинаются с подчеркивания \(\_\). Это говорит Asterisk, что мы ищем совпадение по шаблону, а не по явному имени расширения.

{% hint style="danger" %}
**Предупреждение**

Если вы забудете подчеркивание в начале вашего шаблона, Asterisk подумает, что это просто именованное расширение и не будет выполнять сопоставление шаблонов. Это одна из самых распространенных ошибок, которые люди делают, когда начинают изучать Asterisk.
{% endhint %}

После подчеркивания можно использовать один или несколько следующих символов:

X

Соответствует любой одиночной цифре от 0 до 9.

Z

Соответствует любой одиночной цифре от 1 до 9.

N

Соответствует любой отдельной цифре от 2 до 9.

{% hint style="info" %}
**Примечание**

Другой распространенной ошибкой является попытка использовать буквы `X`, `Z` и `N` буквально в соответствии с шаблоном; для этого оберните их в квадратные скобки \(без учета регистра\), как пример: `_ale[X][Z]A[N]der`.
{% endhint %}

`[15-7]`

Соответствует одному символу из указанного диапазона цифр. В этом случае шаблону соответствует один `1`, а также любое число в диапазоне `5, 6, 7`.

`.` \(период\)

Совпадение с подстановочным знаком; соответствует одному или нескольким символам, независимо от того, что они собой представляют.

{% hint style="danger" %}
**Предупреждение**

Если вы не будете осторожны, подстановочные совпадения могут заставить ваши диалпланы делать то, что вы не ожидаете \(например, сопоставление встроенных расширений, таких как `i` или `h`\). Вы должны использовать подстановочное соответствие в шаблоне только после того, как вы сопоставили как можно больше других цифр. Например, следующий шаблон никогда не должен использоваться:

`_.`

На самом деле, Asterisk предупредит вас, если вы попытаетесь его использовать. Вместо этого, если вам действительно нужно всеохватывающее совпадение шаблона, используйте чтобы соответствовать всем строкам, которые начинаются с цифры, за которой следует один или несколько символов \(см. `!` если хотите иметь возможность соответствовать нулю или более символов\):

`_X.`

Или этот, чтобы соответствовать любой буквенно-цифровой строке:

`_[0-9a-zA-Z].`
{% endhint %}

`!` \(bang\)

Подстановочные знаки совпадают; соответствует нулю или более символов, независимо от того, что они из себя представляют.

Чтобы использовать сопоставление шаблонов в вашем диалплане, просто поместите шаблон вместо имени расширения \(или номера\):

```text
exten => _4XX,1,Noop(User Dialed ${EXTEN})
    same => n,Answer()
    same => n,SayDigits(${EXTEN})
    same => n,Hangup()
```

В этом примере шаблон соответствует любому трехзначному расширению от 400 до 499.

Еще одна важная вещь, которую нужно знать о сопоставлении шаблонов, заключается в том, что если Asterisk найдет более одного шаблона, который соответствует набранному расширению, он будет использовать наиболее конкретный \(слева направо\). Предположим, вы определили следующие два шаблона, и вызывающий абонент набрал 555-1212:

```text
exten => _555XXXX,1,Answer()
    same => n,SayDigits(${EXTEN})
exten => _55512XX,1,Answer()
    same => n,Playback(tt-monkeys)
```

В этом случае будет выбрано второе расширение, поскольку оно более конкретно. Загрузите это и сделайте звонки на 5550000, 5550123, 5551212, 5551200, 5551300, 5551299 и так далее чтобы почувствовать, как это работает. Поиграйте с различными совпадениями шаблонов. Например, что будет соответствовать шаблону \_555NNNN? Что будет соответствовать шаблону \_\[0-9\]?

#### Североамериканский план нумерации - примеры совпадений шаблонов

Этот шаблон соответствует любому семизначному числу, если первая цифра равна 2 или более:

```text
_NXXXXXX
```

Предыдущий шаблон будет совместим с любым североамериканским планом нумерации местного семизначного номера.

В областях с 10-значным набором этот шаблон будет выглядеть следующим образом:

```text
_NXXNXXXXXX
```

Обратите внимание, что ни один из этих двух шаблонов не будет обрабатывать междугородние звонки. Мы рассмотрим их в ближайшее время.

{% hint style="success" %}
**NANP и мошенничество**

Североамериканский план нумерации \(NANP\) - это общая схема нумерации телефонов, используемая 19 странами Северной Америки и Карибского бассейна. Все эти страны имеют общий код страны 1.

В США и Канаде существует достаточная конкуренция, что вы можете сделать междугородний звонок на большинство номеров в коде страны 1 и ожидать разумной платы. Однако многие люди не понимают, что 17 других стран, многие из которых имеют очень разные правила телекоммуникаций, [разделяют NANP](http://www.nanpa.com/). В некоторые из этих мест довольно дорого звонить.

Одна популярная афера с использованием NANP - попытка обмануть наивных североамериканцев в вызове дорогих поминутных платных номеров в карибской стране; абоненты считают, что, поскольку они набрали 1-NPA-NXX-XXXX, чтобы добраться до номера, они будут платить по своему стандартному национальному междугороднему тарифу. Поскольку в рассматриваемой стране могут быть правила, допускающие такую форму вымогательства, абонент в конечном итоге несет ответственность за оплату вызова.

Возможно, будет разумно блокировать звонки на коды регионов в страны NANP за пределами США и Канады, пока у вас не будет возможности пересмотреть свои тарифы на вызовы в эти страны. Википедия имеет [хорошую ссылку](http://bit.ly/2Ztku7l) на основы того, что вам нужно знать о NANP, в том числе какие NPA \(коды регионов\) принадлежат к какой стране.
{% endhint %}

Давайте попробуем другой:

```text
_1NXXNXXXXXX
```

Этот номер будет соответствовать номеру с 1, за которым следует код города между 200 и 999, а затем любое семизначное число, которое не начинается с 0 или 1. В области вызова NANP этот шаблон будет использоваться для сопоставления любого междугороднего номера.

И, наконец, этот:

```text
_011.
```

Обратите внимание на период в конце. Этот шаблон соответствует любому числу, которое начинается с 011 и имеет по крайней мере еще одну цифру. В NANP это указывает на международный номер телефона. \(Мы будем использовать такие шаблоны в следующем разделе, чтобы добавить возможности исходящего набора в нашем диалплане.\)

#### Общие глобальные совпадения шаблонов

За пределами Северной Америки существует большое различие в том, как обрабатывается нумерация; однако некоторые шаблоны являются общими. Вот несколько простых примеров:

```text
; UK, Germany, Italy, China, etc.
exten => _00X.,1,noop() ; международный телефонный код
exten => _0X.,1,noop() ; национальный префикс набора номера
exten => 112,1,Noop(--==[ Экстренный вызов ]==--)
; Австралия
exten => _0011X.,1,noop() ; международный телефонный код
exten => _0X.,1,noop() ; национальный префикс набора номера
; Голландский Карибский Бассейн (Саба)
exten => _00X.,1,noop() ; международный
exten => _416XXXX,1,noop() ; локальный (островной)
exten => _0[37]XXXXXX,1,noop() ; звонок на код страны 599 неостровной (не Кюрасао)
exten => _09XXXXXXX,1,Noop() ; звонок на код страны 599 неостровной (Кюрасао)
```

Вам нужно будет понять план набора номера вашего региона, чтобы произвести полезное совпадение шаблона.

#### Использование канальной переменной ${EXTEN}

Итак, что произойдет, если вы хотите использовать сопоставление шаблонов, но должны знать, какие цифры были фактически набраны? Введите переменную канала `${EXTEN}`. Всякий раз, когда вы набираете расширение, Asterisk записывает полученные цифры в переменную канала `${EXTEN}` . Мы использовали приложение `SayDigits()`, чтобы продемонстрировать это.

```text
exten => _4XX,1,Noop(User Dialed ${EXTEN})
    same => n,Answer()
    same => n,SayDigits(${EXTEN})
    same => n,Hangup()

exten => _555XXXX,1,Answer()
    same => n,SayDigits(${EXTEN})
```

В этих примерах, приложение `SayDigits()` читает номер расширения, которое вы набрали.

Часто бывает полезно манипулировать `${EXTEN}`, удаляя определенное количество цифр с передней части расширения. Это достигается с помощью синтаксиса `${EXTEN:`_`x`_`}`, где _`x`_-это позиция начала возвращаемой строки слева направо. Например, если значение `${EXTEN}` равно `95551212`, `${EXTEN:1}` равно `5551212`. Давайте попробуем другой пример:

```text
exten => _XXX,1,Answer()
    same => n,SayDigits(${EXTEN:1})
```

В этом примере приложение `SayDigits()` будет начинать со второй цифры и, таким образом, считывать только последние две цифры набранного добавочного номера.

{% hint style="success" %}
**Продвинутые возможности манипуляций с цифрами**

Переменная `${EXTEN}` в общем случае имеет синтаксис `${EXTEN:`_`x`_`:`_`y`_`}`, где _`x`_- начальная позиция, а _`y`_ - количество возвращаемых цифр. Учитывая следующую строку набора :

`94169671111`

мы можем извлечь следующие строки цифр, используя конструкцию `${EXTENT:`_`x`_`:`_`y`_`}` :

* `${EXTEN:1:3}` будет содержать `416`
* `${EXTEN:4:7}` будет содержать `9671111`
* `${EXTEN:-4:4}` начнетсяс 4 цифры с конца и вернет 4 цифры, давая нам `1111`
* `${EXTEN:2:-4}` начнет со второй цифры и исключит последние четыре цифры, давая нам `16967`
* `${EXTEN:-6:-4}` начнет с шестой цифры с конца и исключит последние четыре цифры, давая `67`
* `${EXTEN:1}` даст нам все цифры после первой или `4169671111` \(если количество цифр для возврата оставлено пустым, то вернет всю оставшуюся строку\)

Это очень мощная конструкция, но большинство из этих вариаций не очень распространены в обычном использовании. По большей части вы будете использовать `${EXTEN}` \(или, возможно `${EXTEN:1}` если вам нужно удалить внешний код доступа, например приставку 9\).
{% endhint %}

### Включения \(Includes\)

Asterisk имеет важную функцию, которая позволяет расширениям одного контекста быть доступными из другого контекста. Это достигается за счет использования директивы `include`, которая позволяет нам контролировать доступ к различным разделам диалплана.

Оператор `include` принимает следующую форму, где _`context`_ - это имя удаленного контекста, который мы хотим включить в текущий:

```text
include => context
```

Включение одного контекста в другой позволяет набирать расширения в пределах включенного контекста.

Когда мы включаем другие контексты в наш текущий контекст, мы должны помнить о порядке, в котором мы их включаем. Asterisk сначала попытается сопоставить набранное расширение в текущем контексте. В случае неудачи он затем попытается использовать первый включенный контекст \(включая любые контексты, включенные в этот контекст\), а затем продолжит работу с другими включенными контекстами в том порядке, в котором они были включены.

Мы обсудим директиву include подробнее в [Главе 7](glava-07.md).

## Вывод

И вот он - базовый, но функциональный диалплан. Есть еще многое что мы не рассмотрели, но у вас есть все основы. В следующих главах мы продолжим строить на этом фундаменте.

Если части этого диалплана не имеют смысла, вы можете вернуться и перечитать один или два раздела, прежде чем перейти к следующей главе. Крайне важно, чтобы вы поняли эти принципы и как их применять, поскольку следующие главы основаны на этой информации.

 

\[^1\]Обратите внимание, что пробел явно отсутствует в списке разрешенных символов. Не используйте пробелы в именах контекстов — вам не понравится результат!

 Контекст по умолчанию был популярным способом создания простых конфигураций, но это оказалось несколько проблематичным для безопасности. Лучшая практика в эти дни - это избежать любого его использования.

 Asterisk допускает простую арифметику в пределах приоритета, такого как `n+200` и приоритет `s` \(для same\), но их использование несколько устарело из-за существования меток приоритета. Обратите внимание, что расширения и приоритет `s`- это два разных понятия.

 Хорошо, кормление кошки не является обычным использованием для телефонной системы, но через Asterisk такие вещи не невозможны. Доку Брауну бы это понравилось.

Существует еще одно приложение под названием `Background()`, которое очень похоже на `Playback()` за исключением того, что оно позволяет получать ввод данных от вызывающего абонента. Вы можете прочитать больше об этом приложении в главах [14](glava-14.md) и [16](glava-16.md).

Asterisk выбирает лучший файл на основе затрат на транскодинг — то есть он выбирает файл, который является наименее трудоемким для преобразования в свой собственный аудиоформат. Когда вы запускаете Asterisk, он вычисляет затраты на перевод между различными аудиоформатами \(они часто варьируются от системы к системе\). Вы можете увидеть эти затраты на перевод, набрав `core show translation` в Asterisk CLI. Приведенные цифры показывают, сколько микросекунд требуется Asterisk для перекодирования одной секунды звука.

 Если вы еще не настроили два телефона, пожалуйста, вернитесь к [Главе 5](glava-05.md) и установите несколько телефонов, чтобы вы могли играть с ними. Вы можете уйти только с одним телефоном для тестирования, но на самом деле два идеально подходит. Есть много бесплатных софтфонов, и некоторые из них довольно хороши.

 Следует отметить, что некоторые люди ожидают, что `Background()` из-за его названия, будет продолжаться дальше через следующие шаги в диалплане во время воспроизведения звука. На самом деле, его название относится к тому, что он воспроизводит звук в фоновом режиме, ожидая DTMF на переднем плане.

 Дополнительную информацию об автосекретарях и IVR можно найти в [Главе 14](glava-14.md).

 Смотри функцию диалплана `TIMEOUT()` для получения информации о том, как изменить тайм-ауты по умолчанию. См. [Главу 10](glava-10.md) для получения информации о том, что такое функции диалплана.

 Расширение `i` предназначено для перехвата недопустимых значений, предоставленных приложением диалплана, например `Background()`. Он не используется для сопоставления на неверно набранные номера или несовпадения шаблонов.

 Или каналов, если вы хотите звонить более чем по одному за раз.

 IAX2 \(произносится как "EEKS"\), является протоколом обмена между Asterisk \(v2\). В первые дни Asterisk он был популярен для транкинга, поскольку значительно уменьшал накладные расходы сигнализации на занятых линиях. Пропускная способность стала намного меньше, а протокол SIP стал почти повсеместным. Протокол IAX2 больше не поддерживается активно, но он по-прежнему сохраняет некоторую популярность за свою способность пересекать брандмауэры, и поддержку нескольких медиапотоков. Тем не менее, его использование является устаревшим, и на самом деле не рекомендуется.

 Мы рассмотрим переменные в разделе “[Использование переменных](glava-06.md#ispolzovanie-peremennykh)”. В следующих главах мы обсудим, как заставить ваш диалплан принимать решения, основанные на значении `DIALSTATUS`.

 Имейте в виду, что это предполагает, что этот канал подключается к чему-то, что знает, как достичь внешних чисел.

 В частности, то, что мы устанавливаем здесь, является переменной канала.

 Позже мы перейдем к функциям диалплана. Не беспокойтесь слишком о переменных окружения прямо сейчас. Они не важны для понимания диалплана.

 Мы использовали переменную канала EXTEN, без введения в неё. Читайте дальше, как это будет рассмотрено ниже в этой главе.

 Если вы выросли в Северной Америке, то можете полагать, что 1, которую вы набираете перед междугородним звонком - это “междугородний код.” Это не совсем правильно. Число 1 также является международным кодом страны для NANP. Имейте это в виду, если отправляете свой номер телефона кому-то в другой стране. Получатель может не знать код вашей страны, и поэтому не сможет позвонить вам только с вашим кодом города и номером телефона. Ваш полный номер телефона с кодом страны +1 NPA NXX XXXX \(где NPA - ваш код города\) - например, +1 416 555 1212. Это также известно как формат E. 164 \([Wikipedia](http://bit.ly/2ImniNO) может рассказать вам все о E.164\).

